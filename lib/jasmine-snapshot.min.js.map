{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///jasmine-snapshot.min.js","webpack:///webpack/bootstrap c5f0041b0c9d151c5a64","webpack:///./~/himalaya/lib/compat.js","webpack:///./src/overrideconsole.ts","webpack:///./src/parsers/index.ts","webpack:///external \"difflib\"","webpack:///external \"vkbeautify\"","webpack:///./~/himalaya/lib/format.js","webpack:///./~/himalaya/lib/index.js","webpack:///./~/himalaya/lib/lexer.js","webpack:///./~/himalaya/lib/parser.js","webpack:///./~/himalaya/lib/stringify.js","webpack:///./~/himalaya/lib/tags.js","webpack:///./src/index.ts","webpack:///./src/parsers/himalaya.ts","webpack:///./src/parsers/x2js.ts","webpack:///external \"x2js\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_4__","__WEBPACK_EXTERNAL_MODULE_14__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","startsWith","str","searchString","position","substr","length","endsWith","index","lastIndex","lastIndexOf","stringIncludes","indexOf","isRealNaN","x","isNaN","arrayIncludes","array","searchElement","len","lookupIndex","isNaNElement","searchIndex","element","nativeWarn","console","warn","arguments","apply","nativeError","error","himalaya_1","himalaya","parse","x2js_1","x2js","default","parser","splitHead","sep","idx","slice","unquote","car","charAt","end","format","nodes","options","map","node","type","outputNode","tagName","toLowerCase","attributes","formatAttributes","children","content","includePositions","attribute","parts","trim","key","_interopRequireDefault","obj","undefined","parseDefaults","tokens","_lexer2","_parser2","_format","stringify","ast","_stringify","toHTML","_lexer","_parser","_tags","voidTags","closingTags","childlessTags","closingTagAncestorBreakers","feedPosition","start","line","column","jumpPosition","makeInitialPosition","copyPosition","lexer","state","lex","lexText","_compat","lexComment","lexTag","safeTag","lexSkipTag","findTextEnd","textEnd","char","alphanumeric","test","push","contentEnd","commentEnd","secondChar","close","lexTagName","lexTagAttributes","firstChar","_close","isWhitespaceChar","whitespace","_char","cursor","quote","wordBegin","words","wLen","word","secondWord","newWord","thirdWord","_newWord","_secondWord","_newWord3","_newWord2","safeTagName","nextTag","tagStartPosition","tagState","textStart","stack","hasTerminalParent","terminals","tagParents","currentIndex","parentTagName","rewindStack","newLength","childrenEndPosition","endPosition","splice","token","tagToken","shouldRewind","isClosingTag","shouldRewindToAutoClose","previousIndex","attrToken","elementNode","size","innerState","reduce","attrs","quoteEscape","tree","join","li","dt","dd","tbody","thead","tfoot","tr","td","registerSnapshots","snapshot_object","current_snapshot_object","current_suite","AutoSnapshotSuite","current_level","ResetExceptionList","KeyExceptionList","MatchesSnapshot","snapshot","actual","automagic","diff","difflib","unifiedDiff","split","reportFailure","diff_string_1","current_spec","forEach","one_line_actual","create_one_liner","fail","replace","MatchesXMLSnapshot","expectxml","toMatchSnapshot","MatchesJSONSnapshot","prettyActual","vkbeautify_1","json","MatchesJSSnapshot","expectjs","SnapshotJSInner","xml_actual","parserOptions","SnapshotXMLInner","__extends","extendStatics","setPrototypeOf","__proto__","Array","b","__","constructor","create","parsers_1","AutoSnapshot","auto_snapshot_siute_history","snapshot_level","suite_name","snapshots","level","fail_counter_for_autosnapshot","last_automagic_snapshot_spec","last_automagic_snapshot_number","getSnapshotAutomagically_saveActual","auto_snapshot","text","hasFailure","getText","snapshot_file_text","has_snapshots","_i","_a","pushToHistory","getHTML","document","body","style","fontFamily","whiteSpace","snapshot_file_html","jasmine","getEnv","addReporter","suiteStarted","result","specStarted","fullName","suiteDone","jasmineDone","results","html_summary","prev_html","curr_suite","innerHTML","log","SnapshotInner","afterApplying","transformFunction","_super","_this","parsed_values","getOrderedStringifyAndClean","prettySnapshot","use_autosnapshot","keys","collectAllKeysAndRemoveCircular","JSON","js_object","allKeys","jsonStr","val","isIEPooOrCurcularReferences","sort","a","some","ex","IsCurcularDependency","removeEmptyNodes","filter","stripWhitespace","removeWhitespace","xml","preservesWhitespace","X2JS","xml2js"],"mappings":"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","file":"jasmine-snapshot.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"difflib\"), require(\"vkbeautify\"), require(\"x2js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"jasmine-snapshot\", [\"difflib\", \"vkbeautify\", \"x2js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jasmine-snapshot\"] = factory(require(\"difflib\"), require(\"vkbeautify\"), require(\"x2js\"));\n\telse\n\t\troot[\"jasmine-snapshot\"] = factory(root[\"difflib\"], root[\"vkbeautify\"], root[\"x2js\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_14__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"difflib\"), require(\"vkbeautify\"), require(\"x2js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"jasmine-snapshot\", [\"difflib\", \"vkbeautify\", \"x2js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jasmine-snapshot\"] = factory(require(\"difflib\"), require(\"vkbeautify\"), require(\"x2js\"));\n\telse\n\t\troot[\"jasmine-snapshot\"] = factory(root[\"difflib\"], root[\"vkbeautify\"], root[\"x2js\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_14__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.stringIncludes = stringIncludes;\nexports.isRealNaN = isRealNaN;\nexports.arrayIncludes = arrayIncludes;\n/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\n\nfunction startsWith(str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString;\n}\n\nfunction endsWith(str, searchString, position) {\n  var index = (position || str.length) - searchString.length;\n  var lastIndex = str.lastIndexOf(searchString, index);\n  return lastIndex !== -1 && lastIndex === index;\n}\n\nfunction stringIncludes(str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1;\n}\n\nfunction isRealNaN(x) {\n  return typeof x === 'number' && isNaN(x);\n}\n\nfunction arrayIncludes(array, searchElement, position) {\n  var len = array.length;\n  if (len === 0) return false;\n\n  var lookupIndex = position | 0;\n  var isNaNElement = isRealNaN(searchElement);\n  var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;\n  while (searchIndex < len) {\n    var element = array[searchIndex++];\n    if (element === searchElement) return true;\n    if (isNaNElement && isRealNaN(element)) return true;\n  }\n\n  return false;\n}\n//# sourceMappingURL=compat.js.map\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar nativeWarn = console.warn;\nconsole.warn = function () {\n    if ((arguments.length > 0)\n        && (typeof arguments[0] === \"string\")\n        && (arguments[0].indexOf(\"[xmldom \") !== -1)) {\n        return;\n    }\n    nativeWarn.apply(console, arguments);\n};\nvar nativeError = console.error;\nconsole.error = function () {\n    if ((arguments.length > 0)\n        && (typeof arguments[0] === \"string\")\n        && (arguments[0].indexOf(\"entity not found\") !== -1)) {\n        return;\n    }\n    nativeError.apply(console, arguments);\n};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar himalaya_1 = __webpack_require__(12);\nexports.himalaya = himalaya_1.parse;\nvar x2js_1 = __webpack_require__(13);\nexports.x2js = x2js_1.parse;\nexports.default = (function (parser) {\n    switch (parser) {\n        case \"himalaya\":\n            return himalaya_1.parse;\n        default:\n            return x2js_1.parse;\n    }\n});\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.splitHead = splitHead;\nexports.unquote = unquote;\nexports.format = format;\nexports.formatAttributes = formatAttributes;\nfunction splitHead(str, sep) {\n  var idx = str.indexOf(sep);\n  if (idx === -1) return [str];\n  return [str.slice(0, idx), str.slice(idx + sep.length)];\n}\n\nfunction unquote(str) {\n  var car = str.charAt(0);\n  var end = str.length - 1;\n  var isQuoteStart = car === '\"' || car === \"'\";\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end);\n  }\n  return str;\n}\n\nfunction format(nodes, options) {\n  return nodes.map(function (node) {\n    var type = node.type;\n    var outputNode = type === 'element' ? {\n      type: type,\n      tagName: node.tagName.toLowerCase(),\n      attributes: formatAttributes(node.attributes),\n      children: format(node.children, options)\n    } : { type: type, content: node.content };\n    if (options.includePositions) {\n      outputNode.position = node.position;\n    }\n    return outputNode;\n  });\n}\n\nfunction formatAttributes(attributes) {\n  return attributes.map(function (attribute) {\n    var parts = splitHead(attribute.trim(), '=');\n    var key = parts[0];\n    var value = typeof parts[1] === 'string' ? unquote(parts[1]) : null;\n    return { key: key, value: value };\n  });\n}\n//# sourceMappingURL=format.js.map\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDefaults = undefined;\nexports.parse = parse;\nexports.stringify = stringify;\n\nvar _lexer = __webpack_require__(7);\n\nvar _lexer2 = _interopRequireDefault(_lexer);\n\nvar _parser = __webpack_require__(8);\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _format = __webpack_require__(5);\n\nvar _stringify = __webpack_require__(9);\n\nvar _tags = __webpack_require__(10);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar parseDefaults = exports.parseDefaults = {\n  voidTags: _tags.voidTags,\n  closingTags: _tags.closingTags,\n  childlessTags: _tags.childlessTags,\n  closingTagAncestorBreakers: _tags.closingTagAncestorBreakers,\n  includePositions: false\n};\n\nfunction parse(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  var tokens = (0, _lexer2.default)(str, options);\n  var nodes = (0, _parser2.default)(tokens, options);\n  return (0, _format.format)(nodes, options);\n}\n\nfunction stringify(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  return (0, _stringify.toHTML)(ast, options);\n}\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.feedPosition = feedPosition;\nexports.jumpPosition = jumpPosition;\nexports.makeInitialPosition = makeInitialPosition;\nexports.copyPosition = copyPosition;\nexports.default = lexer;\nexports.lex = lex;\nexports.findTextEnd = findTextEnd;\nexports.lexText = lexText;\nexports.lexComment = lexComment;\nexports.lexTag = lexTag;\nexports.isWhitespaceChar = isWhitespaceChar;\nexports.lexTagName = lexTagName;\nexports.lexTagAttributes = lexTagAttributes;\nexports.lexSkipTag = lexSkipTag;\n\nvar _compat = __webpack_require__(0);\n\nfunction feedPosition(position, str, len) {\n  var start = position.index;\n  var end = position.index = start + len;\n  for (var i = start; i < end; i++) {\n    var char = str.charAt(i);\n    if (char === '\\n') {\n      position.line++;\n      position.column = 0;\n    } else {\n      position.column++;\n    }\n  }\n}\n\nfunction jumpPosition(position, str, end) {\n  var len = end - position.index;\n  return feedPosition(position, str, len);\n}\n\nfunction makeInitialPosition() {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  };\n}\n\nfunction copyPosition(position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  };\n}\n\nfunction lexer(str, options) {\n  var state = {\n    str: str,\n    options: options,\n    position: makeInitialPosition(),\n    tokens: []\n  };\n  lex(state);\n  return state.tokens;\n}\n\nfunction lex(state) {\n  var str = state.str,\n      childlessTags = state.options.childlessTags;\n\n  var len = str.length;\n  while (state.position.index < len) {\n    var start = state.position.index;\n    lexText(state);\n    if (state.position.index === start) {\n      var isComment = (0, _compat.startsWith)(str, '!--', start + 1);\n      if (isComment) {\n        lexComment(state);\n      } else {\n        var tagName = lexTag(state);\n        var safeTag = tagName.toLowerCase();\n        if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state);\n        }\n      }\n    }\n  }\n}\n\nvar alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n  while (true) {\n    var textEnd = str.indexOf('<', index);\n    if (textEnd === -1) {\n      return textEnd;\n    }\n    var char = str.charAt(textEnd + 1);\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd;\n    }\n    index = textEnd + 1;\n  }\n}\n\nfunction lexText(state) {\n  var type = 'text';\n  var str = state.str,\n      position = state.position;\n\n  var textEnd = findTextEnd(str, position.index);\n  if (textEnd === position.index) return;\n  if (textEnd === -1) {\n    textEnd = str.length;\n  }\n\n  var start = copyPosition(position);\n  var content = str.slice(position.index, textEnd);\n  jumpPosition(position, str, textEnd);\n  var end = copyPosition(position);\n  state.tokens.push({ type: type, content: content, position: { start: start, end: end } });\n}\n\nfunction lexComment(state) {\n  var str = state.str,\n      position = state.position;\n\n  var start = copyPosition(position);\n  feedPosition(position, str, 4); // \"<!--\".length\n  var contentEnd = str.indexOf('-->', position.index);\n  var commentEnd = contentEnd + 3; // \"-->\".length\n  if (contentEnd === -1) {\n    contentEnd = commentEnd = str.length;\n  }\n\n  var content = str.slice(position.index, contentEnd);\n  jumpPosition(position, str, commentEnd);\n  state.tokens.push({\n    type: 'comment',\n    content: content,\n    position: {\n      start: start,\n      end: copyPosition(position)\n    }\n  });\n}\n\nfunction lexTag(state) {\n  var str = state.str,\n      position = state.position;\n\n  {\n    var secondChar = str.charAt(position.index + 1);\n    var close = secondChar === '/';\n    var start = copyPosition(position);\n    feedPosition(position, str, close ? 2 : 1);\n    state.tokens.push({ type: 'tag-start', close: close, position: { start: start } });\n  }\n  var tagName = lexTagName(state);\n  lexTagAttributes(state);\n  {\n    var firstChar = str.charAt(position.index);\n    var _close = firstChar === '/';\n    feedPosition(position, str, _close ? 2 : 1);\n    var end = copyPosition(position);\n    state.tokens.push({ type: 'tag-end', close: _close, position: { end: end } });\n  }\n  return tagName;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nvar whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n  return whitespace.test(char);\n}\n\nfunction lexTagName(state) {\n  var str = state.str,\n      position = state.position;\n\n  var len = str.length;\n  var start = position.index;\n  while (start < len) {\n    var char = str.charAt(start);\n    var isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n    if (isTagChar) break;\n    start++;\n  }\n\n  var end = start + 1;\n  while (end < len) {\n    var _char = str.charAt(end);\n    var _isTagChar = !(isWhitespaceChar(_char) || _char === '/' || _char === '>');\n    if (!_isTagChar) break;\n    end++;\n  }\n\n  jumpPosition(position, str, end);\n  var tagName = str.slice(start, end);\n  state.tokens.push({\n    type: 'tag',\n    content: tagName\n  });\n  return tagName;\n}\n\nfunction lexTagAttributes(state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n\n  var cursor = position.index;\n  var quote = null; // null, single-, or double-quote\n  var wordBegin = cursor; // index of word start\n  var words = []; // \"key\", \"key=value\", \"key='value'\", etc\n  var len = str.length;\n  while (cursor < len) {\n    var char = str.charAt(cursor);\n    if (quote) {\n      var isQuoteEnd = char === quote;\n      if (isQuoteEnd) {\n        quote = null;\n      }\n      cursor++;\n      continue;\n    }\n\n    var isTagEnd = char === '/' || char === '>';\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      break;\n    }\n\n    var isWordEnd = isWhitespaceChar(char);\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      wordBegin = cursor + 1;\n      cursor++;\n      continue;\n    }\n\n    var isQuoteStart = char === '\\'' || char === '\"';\n    if (isQuoteStart) {\n      quote = char;\n      cursor++;\n      continue;\n    }\n\n    cursor++;\n  }\n  jumpPosition(position, str, cursor);\n\n  var wLen = words.length;\n  var type = 'attribute';\n  for (var i = 0; i < wLen; i++) {\n    var word = words[i];\n    var isNotPair = word.indexOf('=') === -1;\n    if (isNotPair) {\n      var secondWord = words[i + 1];\n      if (secondWord && (0, _compat.startsWith)(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          var newWord = word + secondWord;\n          tokens.push({ type: type, content: newWord });\n          i += 1;\n          continue;\n        }\n        var thirdWord = words[i + 2];\n        i += 1;\n        if (thirdWord) {\n          var _newWord = word + '=' + thirdWord;\n          tokens.push({ type: type, content: _newWord });\n          i += 1;\n          continue;\n        }\n      }\n    }\n    if ((0, _compat.endsWith)(word, '=')) {\n      var _secondWord = words[i + 1];\n      if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, '=')) {\n        var _newWord3 = word + _secondWord;\n        tokens.push({ type: type, content: _newWord3 });\n        i += 1;\n        continue;\n      }\n\n      var _newWord2 = word.slice(0, -1);\n      tokens.push({ type: type, content: _newWord2 });\n      continue;\n    }\n\n    tokens.push({ type: type, content: word });\n  }\n}\n\nvar push = [].push;\n\nfunction lexSkipTag(tagName, state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n\n  var safeTagName = tagName.toLowerCase();\n  var len = str.length;\n  var index = position.index;\n  while (index < len) {\n    var nextTag = str.indexOf('</', index);\n    if (nextTag === -1) {\n      lexText(state);\n      break;\n    }\n\n    var tagStartPosition = copyPosition(position);\n    jumpPosition(tagStartPosition, str, nextTag);\n    var tagState = { str: str, position: tagStartPosition, tokens: [] };\n    var name = lexTag(tagState);\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.position.index;\n      continue;\n    }\n\n    if (nextTag !== position.index) {\n      var textStart = copyPosition(position);\n      jumpPosition(position, str, nextTag);\n      tokens.push({\n        type: 'text',\n        content: str.slice(textStart.index, nextTag),\n        position: {\n          start: textStart,\n          end: copyPosition(position)\n        }\n      });\n    }\n\n    push.apply(tokens, tagState.tokens);\n    jumpPosition(position, str, tagState.position.index);\n    break;\n  }\n}\n//# sourceMappingURL=lexer.js.map\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.rewindStack = rewindStack;\nexports.parse = parse;\n\nvar _compat = __webpack_require__(0);\n\nfunction parser(tokens, options) {\n  var root = { tagName: null, children: [] };\n  var state = { tokens: tokens, options: options, cursor: 0, stack: [root] };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n      if (parentTagName === tagName) {\n        break;\n      }\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n      currentIndex--;\n    }\n  }\n  return false;\n}\n\nfunction rewindStack(stack, newLength, childrenEndPosition, endPosition) {\n  stack[newLength].position.end = endPosition;\n  for (var i = newLength + 1, len = stack.length; i < len; i++) {\n    stack[i].position.end = childrenEndPosition;\n  }\n  stack.splice(newLength);\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n    if (token.close) {\n      var index = stack.length;\n      var shouldRewind = false;\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          shouldRewind = true;\n          break;\n        }\n      }\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n      if (shouldRewind) {\n        rewindStack(stack, index, token.position.start, tokens[cursor - 1].position.end);\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          rewindStack(stack, currentIndex, token.position.start, token.position.start);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    var position = {\n      start: token.position.start,\n      end: attrToken.position.end\n    };\n    var elementNode = {\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children,\n      position: position\n    };\n    nodes.push(elementNode);\n\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n    if (hasChildren) {\n      var size = stack.push({ tagName: tagName, children: children, position: position });\n      var innerState = { tokens: tokens, options: options, cursor: cursor, stack: stack };\n      parse(innerState);\n      cursor = innerState.cursor;\n      var rewoundInElement = stack.length === size;\n      if (rewoundInElement) {\n        elementNode.position.end = tokens[cursor - 1].position.end;\n      }\n    }\n  }\n  state.cursor = cursor;\n}\n//# sourceMappingURL=parser.js.map\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatAttributes = formatAttributes;\nexports.toHTML = toHTML;\n\nvar _compat = __webpack_require__(0);\n\nfunction formatAttributes(attributes) {\n  return attributes.reduce(function (attrs, attribute) {\n    var key = attribute.key,\n        value = attribute.value;\n\n    if (value === null) {\n      return attrs + ' ' + key;\n    }\n    var quoteEscape = value.indexOf('\\'') !== -1;\n    var quote = quoteEscape ? '\"' : '\\'';\n    return attrs + ' ' + key + '=' + quote + value + quote;\n  }, '');\n}\n\nfunction toHTML(tree, options) {\n  return tree.map(function (node) {\n    if (node.type === 'text') {\n      return node.content;\n    }\n    if (node.type === 'comment') {\n      return '<!--' + node.content + '-->';\n    }\n    var tagName = node.tagName,\n        attributes = node.attributes,\n        children = node.children;\n\n    var isSelfClosing = (0, _compat.arrayIncludes)(options.voidTags, tagName.toLowerCase());\n    return isSelfClosing ? '<' + tagName + formatAttributes(attributes) + '>' : '<' + tagName + formatAttributes(attributes) + '>' + toHTML(children, options) + '</' + tagName + '>';\n  }).join('');\n}\n\nexports.default = { toHTML: toHTML };\n//# sourceMappingURL=stringify.js.map\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Tags which contain arbitary non-parsed content\n  For example: <script> JavaScript should not be parsed\n*/\nvar childlessTags = exports.childlessTags = ['style', 'script', 'template'];\n\n/*\n  Tags which auto-close because they cannot be nested\n  For example: <p>Outer<p>Inner is <p>Outer</p><p>Inner</p>\n*/\nvar closingTags = exports.closingTags = ['html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option', 'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'];\n\n/*\n  Closing tags which have ancestor tags which\n  may exist within them which prevent the\n  closing tag from auto-closing.\n  For example: in <li><ul><li></ul></li>,\n  the top-level <li> should not auto-close.\n*/\nvar closingTagAncestorBreakers = exports.closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n};\n\n/*\n  Tags which do not need the closing tag\n  For example: <img> does not need </img>\n*/\nvar voidTags = exports.voidTags = ['!doctype', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n//# sourceMappingURL=tags.js.map\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar difflib = __webpack_require__(3);\nvar vkbeautify_1 = __webpack_require__(4);\nvar parsers_1 = __webpack_require__(2);\n__webpack_require__(1);\nvar current_snapshot_object = {};\nfunction registerSnapshots(snapshot_object, name) {\n    current_snapshot_object = snapshot_object;\n    current_suite = new AutoSnapshotSuite(current_level, name);\n}\nexports.registerSnapshots = registerSnapshots;\nvar AutoSnapshot = (function () {\n    function AutoSnapshot() {\n    }\n    return AutoSnapshot;\n}());\nvar auto_snapshot_siute_history = new Array();\nvar AutoSnapshotSuite = (function () {\n    function AutoSnapshotSuite(snapshot_level, suite_name) {\n        this.snapshots = Array();\n        this.level = 0;\n        this.fail_counter_for_autosnapshot = 0;\n        this.last_automagic_snapshot_spec = \"\";\n        this.last_automagic_snapshot_number = 0;\n        this.level = snapshot_level;\n        this.name = suite_name;\n    }\n    AutoSnapshotSuite.prototype.getSnapshotAutomagically_saveActual = function (actual) {\n        var auto_snapshot = new AutoSnapshot();\n        if (current_spec === this.last_automagic_snapshot_spec) {\n            this.last_automagic_snapshot_number++;\n        }\n        else {\n            this.last_automagic_snapshot_number = 1;\n            this.last_automagic_snapshot_spec = current_spec;\n        }\n        auto_snapshot.key = create_one_liner(current_spec + \" \" + this.last_automagic_snapshot_number);\n        auto_snapshot.text = create_one_liner(actual);\n        this.snapshots.push(auto_snapshot);\n        var snapshot = current_snapshot_object[auto_snapshot.key];\n        return snapshot ? snapshot : \"\";\n    };\n    AutoSnapshotSuite.prototype.hasFailure = function () {\n        return this.fail_counter_for_autosnapshot > 0;\n    };\n    AutoSnapshotSuite.prototype.reportFailure = function (diff) {\n        this.snapshots[this.snapshots.length - 1].diff = diff;\n        this.fail_counter_for_autosnapshot++;\n    };\n    AutoSnapshotSuite.prototype.getText = function () {\n        var snapshot_file_text = \"\\n**** If actual is valid, update your snapshot with the following ****\\n{\";\n        var has_snapshots = false;\n        for (var _i = 0, _a = this.snapshots; _i < _a.length; _i++) {\n            var snapshot = _a[_i];\n            has_snapshots = true;\n            snapshot_file_text += \"\\n\\t\\\"\" + snapshot.key + \"\\\": `\" + snapshot.text + \"`,\";\n        }\n        if (has_snapshots) {\n            snapshot_file_text = snapshot_file_text.slice(0, snapshot_file_text.length - 1);\n            snapshot_file_text += \"\\n}\\n\\n\";\n        }\n        return snapshot_file_text;\n    };\n    AutoSnapshotSuite.prototype.pushToHistory = function () {\n        auto_snapshot_siute_history.push(this);\n    };\n    AutoSnapshotSuite.prototype.getHTML = function () {\n        if (typeof document !== \"undefined\") {\n            document.body.style.fontFamily = \"Courier New\";\n            document.body.style.whiteSpace = \"nowrap\";\n        }\n        if (!this.name) {\n            throw \"name not defined for snapshot suite\";\n        }\n        if (!this.hasFailure()) {\n            return \"<p style=\\\"color: green; font-size: 25px; font-weight: bold;\\\">===Auto snapshot suite, \" + this.name + \", has no problems!===</p>\";\n        }\n        var snapshot_file_html = \"<p style=\\\"color: red; font-size: 25px; font-weight: bold;\\\">===Suite, \" + this.name + \", had problems===</p>\";\n        this.snapshots.forEach(function (snapshot) {\n            if (snapshot.diff) {\n                snapshot_file_html += \"<div>>Test: \\\"\" + snapshot.key + \"\\\" did not match the snapshot:</div><br //>\";\n                snapshot.diff.forEach(function (d) {\n                    if (d.length >= 3 && (d.slice(0, 3) === \"---\" || d.slice(0, 3) === \"+++\") || d.slice(0, 2) === \"@@\") {\n                        return;\n                    }\n                    else if (d.charAt(0) === \"-\") {\n                        snapshot_file_html += \"<span style=\\\"color: red\\\">\" + d.replace(/&nbsp;/g, \"&amp;nbsp;\").replace(/ /g, \"&nbsp;\") + \"</span><br //>\";\n                    }\n                    else if (d.charAt(0) === \"+\") {\n                        snapshot_file_html += \"<span style=\\\"color: green\\\">\" + d.replace(/&nbsp;/g, \"&amp;nbsp;\").replace(/ /g, \"&nbsp;\") + \"</span><br //>\";\n                    }\n                    else {\n                        snapshot_file_html += d.replace(/&nbsp;/g, \"&amp;nbsp;\").replace(/ /g, \"&nbsp;\") + \"<br //>\";\n                    }\n                });\n            }\n        });\n        snapshot_file_html += \"<p style=\\\"text-decoration: underline; font-weight: bold;\\\">If actual is valid, update your snapshot with the following <//p>\";\n        snapshot_file_html += \"<div style='color: blue;'>{\";\n        var has_snapshots = false;\n        for (var _i = 0, _a = this.snapshots; _i < _a.length; _i++) {\n            var snapshot = _a[_i];\n            has_snapshots = true;\n            snapshot_file_html += \"<br //>&nbsp;&nbsp;&nbsp;&nbsp;\\\"\" + snapshot.key + \"\\\": `\" + snapshot.text.replace(/&nbsp;/g, \"&amp;nbsp;\") + \"`,\";\n        }\n        if (has_snapshots) {\n            snapshot_file_html = snapshot_file_html.slice(0, snapshot_file_html.length - 1);\n            snapshot_file_html += \"<br //>}</div></p>\";\n        }\n        return snapshot_file_html;\n    };\n    return AutoSnapshotSuite;\n}());\nvar current_suite;\nvar current_spec = \"\";\nvar current_level = 0;\njasmine.getEnv().addReporter({\n    suiteStarted: function (result) {\n        current_level++;\n    },\n    specStarted: function (result) {\n        current_spec = result.fullName;\n    },\n    suiteDone: function (result) {\n        current_level--;\n        if (current_suite && current_level < current_suite.level) {\n            if (current_suite.hasFailure) {\n            }\n            current_suite.pushToHistory();\n            current_suite = null;\n        }\n    },\n    jasmineDone: function (results) {\n        if (current_suite) {\n            if (current_suite.hasFailure) {\n            }\n            current_suite.pushToHistory();\n            current_suite = null;\n        }\n        if (auto_snapshot_siute_history.length === 0) {\n            return;\n        }\n        var html_summary = auto_snapshot_siute_history.reduce(function (prev_html, curr_suite) {\n            return prev_html + \"<br //>\" + curr_suite.getHTML();\n        }, \"\");\n        if (typeof document !== \"undefined\") {\n            document.body.innerHTML = html_summary + document.body.innerHTML;\n        }\n        else {\n            console.log(html_summary);\n        }\n    }\n});\nexports.KeyExceptionList = [\"typeof\"];\nfunction ResetExceptionList() {\n    exports.KeyExceptionList = [\"typeof\"];\n}\nexports.ResetExceptionList = ResetExceptionList;\nfunction MatchesSnapshot(snapshot, actual, automagic) {\n    if (actual !== snapshot) {\n        var diff = difflib.unifiedDiff(snapshot.split(\"\\n\"), actual.split(\"\\n\"));\n        if (automagic) {\n            if (!current_suite) {\n                throw \"autoagic snapshot with no registered snapshot object\";\n            }\n            current_suite.reportFailure(diff);\n        }\n        var diff_string_1 = \"\\n\";\n        diff_string_1 += \"**** \" + current_spec + \" diff *****\\n\\n\";\n        diff.forEach(function (d) {\n            if (d !== \"--- \\n\" && d !== \"+++ \\n\" &&\n                !(d.length > 5 && d.slice(0, 2) === \"@@\")) {\n                diff_string_1 += d + \"\\n\";\n            }\n        });\n        diff_string_1 += \"\\n\";\n        if (!automagic) {\n            var one_line_actual = create_one_liner(actual);\n            diff_string_1 += \"**** If the Actual is valid, update the snapshot with this ****\\n\";\n            diff_string_1 += \" ----- Formatted ------\\n\" + actual + \"\\n\\n ----- Single Line ------\\n\" + one_line_actual;\n        }\n        console.error(diff_string_1);\n        fail(\"Actual does not match snapshot. See above. \");\n    }\n}\nexports.MatchesSnapshot = MatchesSnapshot;\nfunction create_one_liner(actual) {\n    var one_line_actual = actual.replace(/\\n/g, \"\").replace(/\\t/g, \"\").replace(/\\\\\"/g, \"\\\\\\\\\\\\\\\"\");\n    while (one_line_actual.indexOf(\"  \") !== -1) {\n        one_line_actual = one_line_actual.replace(/(  )/g, \" \");\n    }\n    return one_line_actual;\n}\nfunction MatchesXMLSnapshot(snapshot, actual) {\n    expectxml(actual).toMatchSnapshot(snapshot);\n}\nexports.MatchesXMLSnapshot = MatchesXMLSnapshot;\nfunction MatchesJSONSnapshot(snapshot, actual) {\n    var prettyActual = actual ? vkbeautify_1.json(actual) : actual;\n    var prettySnapshot = snapshot ? vkbeautify_1.json(snapshot) : snapshot;\n    MatchesSnapshot(prettySnapshot, prettyActual);\n}\nexports.MatchesJSONSnapshot = MatchesJSONSnapshot;\nfunction MatchesJSSnapshot(snapshot, actual) {\n    expectjs(actual).toMatchSnapshot(snapshot);\n}\nexports.MatchesJSSnapshot = MatchesJSSnapshot;\nfunction expectjs(actual) {\n    return new SnapshotJSInner(actual);\n}\nexports.expectjs = expectjs;\nfunction expectxml(xml_actual, parser, parserOptions) {\n    return new SnapshotXMLInner(xml_actual, parser, parserOptions);\n}\nexports.expectxml = expectxml;\nvar SnapshotInner = (function () {\n    function SnapshotInner(actual) {\n        this.actual = actual;\n    }\n    SnapshotInner.prototype.afterApplying = function (transformFunction) {\n        this.actual = transformFunction(this.actual);\n        return this;\n    };\n    return SnapshotInner;\n}());\nvar SnapshotJSInner = (function (_super) {\n    __extends(SnapshotJSInner, _super);\n    function SnapshotJSInner(actual) {\n        var _this = _super.call(this, actual) || this;\n        _this.parsed_values = new Array();\n        _this.actual = actual;\n        return _this;\n    }\n    SnapshotJSInner.prototype.toMatchSnapshot = function (snapshot) {\n        var prettyActual = this.actual ? vkbeautify_1.json(this.getOrderedStringifyAndClean()) : \"\";\n        var prettySnapshot = snapshot;\n        var use_autosnapshot = false;\n        if (snapshot === null || snapshot === undefined) {\n            if (!current_suite) {\n                throw \"Use of autosnapshot without registering snapshot object\";\n            }\n            use_autosnapshot = true;\n            var auto_snapshot = current_suite.getSnapshotAutomagically_saveActual(prettyActual);\n            prettySnapshot = auto_snapshot ? vkbeautify_1.json(auto_snapshot) : \"\";\n        }\n        else {\n            prettySnapshot = snapshot ? vkbeautify_1.json(snapshot) : snapshot;\n        }\n        MatchesSnapshot(prettySnapshot, prettyActual, use_autosnapshot);\n    };\n    SnapshotJSInner.prototype.getOrderedStringifyAndClean = function () {\n        var keys = this.collectAllKeysAndRemoveCircular(this.actual);\n        return JSON.stringify(this.actual, keys);\n    };\n    SnapshotJSInner.prototype.collectAllKeysAndRemoveCircular = function (js_object) {\n        var _this = this;\n        var allKeys = new Array();\n        var jsonStr = JSON.stringify(js_object, function (key, val) {\n            if (_this.isIEPooOrCurcularReferences(key, val)) {\n                return;\n            }\n            allKeys.push(key);\n            return val;\n        });\n        this.actual = JSON.parse(jsonStr);\n        return allKeys.sort(function (a, b) { return (a > b) ? 1 : -1; });\n    };\n    SnapshotJSInner.prototype.isIEPooOrCurcularReferences = function (key, value) {\n        if (typeof key === \"string\" && exports.KeyExceptionList.some(function (ex) { return key.indexOf(ex) !== -1; })) {\n            return true;\n        }\n        else if (this.IsCurcularDependency(value)) {\n            return true;\n        }\n        return false;\n    };\n    SnapshotJSInner.prototype.IsCurcularDependency = function (value) {\n        if (value && typeof value === \"object\") {\n            if (this.parsed_values.indexOf(value) === -1) {\n                this.parsed_values.push(value);\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    return SnapshotJSInner;\n}(SnapshotInner));\nexports.SnapshotJSInner = SnapshotJSInner;\nvar SnapshotXMLInner = (function (_super) {\n    __extends(SnapshotXMLInner, _super);\n    function SnapshotXMLInner(xml_actual, parser, parserOptions) {\n        var _this = _super.call(this, xml_actual) || this;\n        _this.parser = parsers_1.default(parser);\n        _this.parserOptions = parserOptions;\n        _this.actual = xml_actual;\n        return _this;\n    }\n    SnapshotXMLInner.prototype.toMatchSnapshot = function (snapshot) {\n        var js_actual = this.parser(this.actual, this.parserOptions);\n        expectjs(js_actual).toMatchSnapshot(snapshot);\n    };\n    return SnapshotXMLInner;\n}(SnapshotInner));\nexports.SnapshotXMLInner = SnapshotXMLInner;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar himalaya = __webpack_require__(6);\nfunction removeEmptyNodes(nodes) {\n    return nodes.filter(function (node) {\n        if (node.type === \"element\") {\n            node.children = removeEmptyNodes(node.children);\n            return true;\n        }\n        return node.content.length;\n    });\n}\nfunction stripWhitespace(nodes) {\n    return nodes.map(function (node) {\n        if (node.type === \"element\") {\n            node.children = stripWhitespace(node.children);\n        }\n        else {\n            node.content = node.content.trim();\n        }\n        return node;\n    });\n}\nfunction removeWhitespace(nodes) {\n    return removeEmptyNodes(stripWhitespace(nodes));\n}\nexports.parse = function (xml, options) {\n    var json = himalaya.parse(xml);\n    var preservesWhitespace = (options || {}).preservesWhitespace !== false;\n    if (preservesWhitespace) {\n        json = removeWhitespace(json);\n    }\n    return json;\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar X2JS = __webpack_require__(14);\nexports.parse = function (xml) {\n    var X2JS2 = X2JS;\n    var x2js = new X2JS2();\n    return x2js.xml2js(xml);\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// jasmine-snapshot.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c5f0041b0c9d151c5a64","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startsWith = startsWith;\nexports.endsWith = endsWith;\nexports.stringIncludes = stringIncludes;\nexports.isRealNaN = isRealNaN;\nexports.arrayIncludes = arrayIncludes;\n/*\n  We don't want to include babel-polyfill in our project.\n    - Library authors should be using babel-runtime for non-global polyfilling\n    - Adding babel-polyfill/-runtime increases bundle size significantly\n\n  We will include our polyfill instance methods as regular functions.\n*/\n\nfunction startsWith(str, searchString, position) {\n  return str.substr(position || 0, searchString.length) === searchString;\n}\n\nfunction endsWith(str, searchString, position) {\n  var index = (position || str.length) - searchString.length;\n  var lastIndex = str.lastIndexOf(searchString, index);\n  return lastIndex !== -1 && lastIndex === index;\n}\n\nfunction stringIncludes(str, searchString, position) {\n  return str.indexOf(searchString, position || 0) !== -1;\n}\n\nfunction isRealNaN(x) {\n  return typeof x === 'number' && isNaN(x);\n}\n\nfunction arrayIncludes(array, searchElement, position) {\n  var len = array.length;\n  if (len === 0) return false;\n\n  var lookupIndex = position | 0;\n  var isNaNElement = isRealNaN(searchElement);\n  var searchIndex = lookupIndex >= 0 ? lookupIndex : len + lookupIndex;\n  while (searchIndex < len) {\n    var element = array[searchIndex++];\n    if (element === searchElement) return true;\n    if (isNaNElement && isRealNaN(element)) return true;\n  }\n\n  return false;\n}\n//# sourceMappingURL=compat.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/compat.js\n// module id = 0\n// module chunks = 0","let nativeWarn = console.warn;\nconsole.warn = function ()\n{\n    if (\n        (arguments.length > 0)\n        && (typeof arguments[0] === \"string\")\n        && (arguments[0].indexOf(\"[xmldom \") !== -1)\n    )\n    {\n        return;\n    }\n    nativeWarn.apply(console, arguments);\n};\n\nlet nativeError = console.error;\nconsole.error = function ()\n{\n    if (\n        (arguments.length > 0)\n        && (typeof arguments[0] === \"string\")\n        && (arguments[0].indexOf(\"entity not found\") !== -1)\n    )\n    {\n        return;\n    }\n    nativeError.apply(console, arguments);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/overrideconsole.ts","import { parse as himalaya, HimalayaOptions } from \"./himalaya\";\nimport { parse as x2js, Xml2jsOptions } from \"./x2js\";\n\ndeclare type ParserOptions = HimalayaOptions | Xml2jsOptions;\n\nexport {\n    himalaya,\n    x2js,\n    ParserOptions,\n    HimalayaOptions,\n    Xml2jsOptions\n};\n\nexport default (parser) => {\n    switch (parser) {\n        case \"himalaya\":\n            return himalaya;\n\n        default:\n            return x2js;\n    }\n};\n\n\n// WEBPACK FOOTER //\n// ./src/parsers/index.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"difflib\"\n// module id = 3\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_4__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"vkbeautify\"\n// module id = 4\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.splitHead = splitHead;\nexports.unquote = unquote;\nexports.format = format;\nexports.formatAttributes = formatAttributes;\nfunction splitHead(str, sep) {\n  var idx = str.indexOf(sep);\n  if (idx === -1) return [str];\n  return [str.slice(0, idx), str.slice(idx + sep.length)];\n}\n\nfunction unquote(str) {\n  var car = str.charAt(0);\n  var end = str.length - 1;\n  var isQuoteStart = car === '\"' || car === \"'\";\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end);\n  }\n  return str;\n}\n\nfunction format(nodes, options) {\n  return nodes.map(function (node) {\n    var type = node.type;\n    var outputNode = type === 'element' ? {\n      type: type,\n      tagName: node.tagName.toLowerCase(),\n      attributes: formatAttributes(node.attributes),\n      children: format(node.children, options)\n    } : { type: type, content: node.content };\n    if (options.includePositions) {\n      outputNode.position = node.position;\n    }\n    return outputNode;\n  });\n}\n\nfunction formatAttributes(attributes) {\n  return attributes.map(function (attribute) {\n    var parts = splitHead(attribute.trim(), '=');\n    var key = parts[0];\n    var value = typeof parts[1] === 'string' ? unquote(parts[1]) : null;\n    return { key: key, value: value };\n  });\n}\n//# sourceMappingURL=format.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/format.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseDefaults = undefined;\nexports.parse = parse;\nexports.stringify = stringify;\n\nvar _lexer = require('./lexer');\n\nvar _lexer2 = _interopRequireDefault(_lexer);\n\nvar _parser = require('./parser');\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nvar _format = require('./format');\n\nvar _stringify = require('./stringify');\n\nvar _tags = require('./tags');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar parseDefaults = exports.parseDefaults = {\n  voidTags: _tags.voidTags,\n  closingTags: _tags.closingTags,\n  childlessTags: _tags.childlessTags,\n  closingTagAncestorBreakers: _tags.closingTagAncestorBreakers,\n  includePositions: false\n};\n\nfunction parse(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  var tokens = (0, _lexer2.default)(str, options);\n  var nodes = (0, _parser2.default)(tokens, options);\n  return (0, _format.format)(nodes, options);\n}\n\nfunction stringify(ast) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parseDefaults;\n\n  return (0, _stringify.toHTML)(ast, options);\n}\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/index.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.feedPosition = feedPosition;\nexports.jumpPosition = jumpPosition;\nexports.makeInitialPosition = makeInitialPosition;\nexports.copyPosition = copyPosition;\nexports.default = lexer;\nexports.lex = lex;\nexports.findTextEnd = findTextEnd;\nexports.lexText = lexText;\nexports.lexComment = lexComment;\nexports.lexTag = lexTag;\nexports.isWhitespaceChar = isWhitespaceChar;\nexports.lexTagName = lexTagName;\nexports.lexTagAttributes = lexTagAttributes;\nexports.lexSkipTag = lexSkipTag;\n\nvar _compat = require('./compat');\n\nfunction feedPosition(position, str, len) {\n  var start = position.index;\n  var end = position.index = start + len;\n  for (var i = start; i < end; i++) {\n    var char = str.charAt(i);\n    if (char === '\\n') {\n      position.line++;\n      position.column = 0;\n    } else {\n      position.column++;\n    }\n  }\n}\n\nfunction jumpPosition(position, str, end) {\n  var len = end - position.index;\n  return feedPosition(position, str, len);\n}\n\nfunction makeInitialPosition() {\n  return {\n    index: 0,\n    column: 0,\n    line: 0\n  };\n}\n\nfunction copyPosition(position) {\n  return {\n    index: position.index,\n    line: position.line,\n    column: position.column\n  };\n}\n\nfunction lexer(str, options) {\n  var state = {\n    str: str,\n    options: options,\n    position: makeInitialPosition(),\n    tokens: []\n  };\n  lex(state);\n  return state.tokens;\n}\n\nfunction lex(state) {\n  var str = state.str,\n      childlessTags = state.options.childlessTags;\n\n  var len = str.length;\n  while (state.position.index < len) {\n    var start = state.position.index;\n    lexText(state);\n    if (state.position.index === start) {\n      var isComment = (0, _compat.startsWith)(str, '!--', start + 1);\n      if (isComment) {\n        lexComment(state);\n      } else {\n        var tagName = lexTag(state);\n        var safeTag = tagName.toLowerCase();\n        if ((0, _compat.arrayIncludes)(childlessTags, safeTag)) {\n          lexSkipTag(tagName, state);\n        }\n      }\n    }\n  }\n}\n\nvar alphanumeric = /[A-Za-z0-9]/;\nfunction findTextEnd(str, index) {\n  while (true) {\n    var textEnd = str.indexOf('<', index);\n    if (textEnd === -1) {\n      return textEnd;\n    }\n    var char = str.charAt(textEnd + 1);\n    if (char === '/' || char === '!' || alphanumeric.test(char)) {\n      return textEnd;\n    }\n    index = textEnd + 1;\n  }\n}\n\nfunction lexText(state) {\n  var type = 'text';\n  var str = state.str,\n      position = state.position;\n\n  var textEnd = findTextEnd(str, position.index);\n  if (textEnd === position.index) return;\n  if (textEnd === -1) {\n    textEnd = str.length;\n  }\n\n  var start = copyPosition(position);\n  var content = str.slice(position.index, textEnd);\n  jumpPosition(position, str, textEnd);\n  var end = copyPosition(position);\n  state.tokens.push({ type: type, content: content, position: { start: start, end: end } });\n}\n\nfunction lexComment(state) {\n  var str = state.str,\n      position = state.position;\n\n  var start = copyPosition(position);\n  feedPosition(position, str, 4); // \"<!--\".length\n  var contentEnd = str.indexOf('-->', position.index);\n  var commentEnd = contentEnd + 3; // \"-->\".length\n  if (contentEnd === -1) {\n    contentEnd = commentEnd = str.length;\n  }\n\n  var content = str.slice(position.index, contentEnd);\n  jumpPosition(position, str, commentEnd);\n  state.tokens.push({\n    type: 'comment',\n    content: content,\n    position: {\n      start: start,\n      end: copyPosition(position)\n    }\n  });\n}\n\nfunction lexTag(state) {\n  var str = state.str,\n      position = state.position;\n\n  {\n    var secondChar = str.charAt(position.index + 1);\n    var close = secondChar === '/';\n    var start = copyPosition(position);\n    feedPosition(position, str, close ? 2 : 1);\n    state.tokens.push({ type: 'tag-start', close: close, position: { start: start } });\n  }\n  var tagName = lexTagName(state);\n  lexTagAttributes(state);\n  {\n    var firstChar = str.charAt(position.index);\n    var _close = firstChar === '/';\n    feedPosition(position, str, _close ? 2 : 1);\n    var end = copyPosition(position);\n    state.tokens.push({ type: 'tag-end', close: _close, position: { end: end } });\n  }\n  return tagName;\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-white-space\nvar whitespace = /\\s/;\nfunction isWhitespaceChar(char) {\n  return whitespace.test(char);\n}\n\nfunction lexTagName(state) {\n  var str = state.str,\n      position = state.position;\n\n  var len = str.length;\n  var start = position.index;\n  while (start < len) {\n    var char = str.charAt(start);\n    var isTagChar = !(isWhitespaceChar(char) || char === '/' || char === '>');\n    if (isTagChar) break;\n    start++;\n  }\n\n  var end = start + 1;\n  while (end < len) {\n    var _char = str.charAt(end);\n    var _isTagChar = !(isWhitespaceChar(_char) || _char === '/' || _char === '>');\n    if (!_isTagChar) break;\n    end++;\n  }\n\n  jumpPosition(position, str, end);\n  var tagName = str.slice(start, end);\n  state.tokens.push({\n    type: 'tag',\n    content: tagName\n  });\n  return tagName;\n}\n\nfunction lexTagAttributes(state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n\n  var cursor = position.index;\n  var quote = null; // null, single-, or double-quote\n  var wordBegin = cursor; // index of word start\n  var words = []; // \"key\", \"key=value\", \"key='value'\", etc\n  var len = str.length;\n  while (cursor < len) {\n    var char = str.charAt(cursor);\n    if (quote) {\n      var isQuoteEnd = char === quote;\n      if (isQuoteEnd) {\n        quote = null;\n      }\n      cursor++;\n      continue;\n    }\n\n    var isTagEnd = char === '/' || char === '>';\n    if (isTagEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      break;\n    }\n\n    var isWordEnd = isWhitespaceChar(char);\n    if (isWordEnd) {\n      if (cursor !== wordBegin) {\n        words.push(str.slice(wordBegin, cursor));\n      }\n      wordBegin = cursor + 1;\n      cursor++;\n      continue;\n    }\n\n    var isQuoteStart = char === '\\'' || char === '\"';\n    if (isQuoteStart) {\n      quote = char;\n      cursor++;\n      continue;\n    }\n\n    cursor++;\n  }\n  jumpPosition(position, str, cursor);\n\n  var wLen = words.length;\n  var type = 'attribute';\n  for (var i = 0; i < wLen; i++) {\n    var word = words[i];\n    var isNotPair = word.indexOf('=') === -1;\n    if (isNotPair) {\n      var secondWord = words[i + 1];\n      if (secondWord && (0, _compat.startsWith)(secondWord, '=')) {\n        if (secondWord.length > 1) {\n          var newWord = word + secondWord;\n          tokens.push({ type: type, content: newWord });\n          i += 1;\n          continue;\n        }\n        var thirdWord = words[i + 2];\n        i += 1;\n        if (thirdWord) {\n          var _newWord = word + '=' + thirdWord;\n          tokens.push({ type: type, content: _newWord });\n          i += 1;\n          continue;\n        }\n      }\n    }\n    if ((0, _compat.endsWith)(word, '=')) {\n      var _secondWord = words[i + 1];\n      if (_secondWord && !(0, _compat.stringIncludes)(_secondWord, '=')) {\n        var _newWord3 = word + _secondWord;\n        tokens.push({ type: type, content: _newWord3 });\n        i += 1;\n        continue;\n      }\n\n      var _newWord2 = word.slice(0, -1);\n      tokens.push({ type: type, content: _newWord2 });\n      continue;\n    }\n\n    tokens.push({ type: type, content: word });\n  }\n}\n\nvar push = [].push;\n\nfunction lexSkipTag(tagName, state) {\n  var str = state.str,\n      position = state.position,\n      tokens = state.tokens;\n\n  var safeTagName = tagName.toLowerCase();\n  var len = str.length;\n  var index = position.index;\n  while (index < len) {\n    var nextTag = str.indexOf('</', index);\n    if (nextTag === -1) {\n      lexText(state);\n      break;\n    }\n\n    var tagStartPosition = copyPosition(position);\n    jumpPosition(tagStartPosition, str, nextTag);\n    var tagState = { str: str, position: tagStartPosition, tokens: [] };\n    var name = lexTag(tagState);\n    if (safeTagName !== name.toLowerCase()) {\n      index = tagState.position.index;\n      continue;\n    }\n\n    if (nextTag !== position.index) {\n      var textStart = copyPosition(position);\n      jumpPosition(position, str, nextTag);\n      tokens.push({\n        type: 'text',\n        content: str.slice(textStart.index, nextTag),\n        position: {\n          start: textStart,\n          end: copyPosition(position)\n        }\n      });\n    }\n\n    push.apply(tokens, tagState.tokens);\n    jumpPosition(position, str, tagState.position.index);\n    break;\n  }\n}\n//# sourceMappingURL=lexer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/lexer.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parser;\nexports.hasTerminalParent = hasTerminalParent;\nexports.rewindStack = rewindStack;\nexports.parse = parse;\n\nvar _compat = require('./compat');\n\nfunction parser(tokens, options) {\n  var root = { tagName: null, children: [] };\n  var state = { tokens: tokens, options: options, cursor: 0, stack: [root] };\n  parse(state);\n  return root.children;\n}\n\nfunction hasTerminalParent(tagName, stack, terminals) {\n  var tagParents = terminals[tagName];\n  if (tagParents) {\n    var currentIndex = stack.length - 1;\n    while (currentIndex >= 0) {\n      var parentTagName = stack[currentIndex].tagName;\n      if (parentTagName === tagName) {\n        break;\n      }\n      if ((0, _compat.arrayIncludes)(tagParents, parentTagName)) {\n        return true;\n      }\n      currentIndex--;\n    }\n  }\n  return false;\n}\n\nfunction rewindStack(stack, newLength, childrenEndPosition, endPosition) {\n  stack[newLength].position.end = endPosition;\n  for (var i = newLength + 1, len = stack.length; i < len; i++) {\n    stack[i].position.end = childrenEndPosition;\n  }\n  stack.splice(newLength);\n}\n\nfunction parse(state) {\n  var tokens = state.tokens,\n      options = state.options;\n  var stack = state.stack;\n\n  var nodes = stack[stack.length - 1].children;\n  var len = tokens.length;\n  var cursor = state.cursor;\n\n  while (cursor < len) {\n    var token = tokens[cursor];\n    if (token.type !== 'tag-start') {\n      nodes.push(token);\n      cursor++;\n      continue;\n    }\n\n    var tagToken = tokens[++cursor];\n    cursor++;\n    var tagName = tagToken.content.toLowerCase();\n    if (token.close) {\n      var index = stack.length;\n      var shouldRewind = false;\n      while (--index > -1) {\n        if (stack[index].tagName === tagName) {\n          shouldRewind = true;\n          break;\n        }\n      }\n      while (cursor < len) {\n        var endToken = tokens[cursor];\n        if (endToken.type !== 'tag-end') break;\n        cursor++;\n      }\n      if (shouldRewind) {\n        rewindStack(stack, index, token.position.start, tokens[cursor - 1].position.end);\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    var isClosingTag = (0, _compat.arrayIncludes)(options.closingTags, tagName);\n    var shouldRewindToAutoClose = isClosingTag;\n    if (shouldRewindToAutoClose) {\n      var terminals = options.closingTagAncestorBreakers;\n\n      shouldRewindToAutoClose = !hasTerminalParent(tagName, stack, terminals);\n    }\n\n    if (shouldRewindToAutoClose) {\n      // rewind the stack to just above the previous\n      // closing tag of the same name\n      var currentIndex = stack.length - 1;\n      while (currentIndex > 0) {\n        if (tagName === stack[currentIndex].tagName) {\n          rewindStack(stack, currentIndex, token.position.start, token.position.start);\n          var previousIndex = currentIndex - 1;\n          nodes = stack[previousIndex].children;\n          break;\n        }\n        currentIndex = currentIndex - 1;\n      }\n    }\n\n    var attributes = [];\n    var attrToken = void 0;\n    while (cursor < len) {\n      attrToken = tokens[cursor];\n      if (attrToken.type === 'tag-end') break;\n      attributes.push(attrToken.content);\n      cursor++;\n    }\n\n    cursor++;\n    var children = [];\n    var position = {\n      start: token.position.start,\n      end: attrToken.position.end\n    };\n    var elementNode = {\n      type: 'element',\n      tagName: tagToken.content,\n      attributes: attributes,\n      children: children,\n      position: position\n    };\n    nodes.push(elementNode);\n\n    var hasChildren = !(attrToken.close || (0, _compat.arrayIncludes)(options.voidTags, tagName));\n    if (hasChildren) {\n      var size = stack.push({ tagName: tagName, children: children, position: position });\n      var innerState = { tokens: tokens, options: options, cursor: cursor, stack: stack };\n      parse(innerState);\n      cursor = innerState.cursor;\n      var rewoundInElement = stack.length === size;\n      if (rewoundInElement) {\n        elementNode.position.end = tokens[cursor - 1].position.end;\n      }\n    }\n  }\n  state.cursor = cursor;\n}\n//# sourceMappingURL=parser.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/parser.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatAttributes = formatAttributes;\nexports.toHTML = toHTML;\n\nvar _compat = require('./compat');\n\nfunction formatAttributes(attributes) {\n  return attributes.reduce(function (attrs, attribute) {\n    var key = attribute.key,\n        value = attribute.value;\n\n    if (value === null) {\n      return attrs + ' ' + key;\n    }\n    var quoteEscape = value.indexOf('\\'') !== -1;\n    var quote = quoteEscape ? '\"' : '\\'';\n    return attrs + ' ' + key + '=' + quote + value + quote;\n  }, '');\n}\n\nfunction toHTML(tree, options) {\n  return tree.map(function (node) {\n    if (node.type === 'text') {\n      return node.content;\n    }\n    if (node.type === 'comment') {\n      return '<!--' + node.content + '-->';\n    }\n    var tagName = node.tagName,\n        attributes = node.attributes,\n        children = node.children;\n\n    var isSelfClosing = (0, _compat.arrayIncludes)(options.voidTags, tagName.toLowerCase());\n    return isSelfClosing ? '<' + tagName + formatAttributes(attributes) + '>' : '<' + tagName + formatAttributes(attributes) + '>' + toHTML(children, options) + '</' + tagName + '>';\n  }).join('');\n}\n\nexports.default = { toHTML: toHTML };\n//# sourceMappingURL=stringify.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/stringify.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  Tags which contain arbitary non-parsed content\n  For example: <script> JavaScript should not be parsed\n*/\nvar childlessTags = exports.childlessTags = ['style', 'script', 'template'];\n\n/*\n  Tags which auto-close because they cannot be nested\n  For example: <p>Outer<p>Inner is <p>Outer</p><p>Inner</p>\n*/\nvar closingTags = exports.closingTags = ['html', 'head', 'body', 'p', 'dt', 'dd', 'li', 'option', 'thead', 'th', 'tbody', 'tr', 'td', 'tfoot', 'colgroup'];\n\n/*\n  Closing tags which have ancestor tags which\n  may exist within them which prevent the\n  closing tag from auto-closing.\n  For example: in <li><ul><li></ul></li>,\n  the top-level <li> should not auto-close.\n*/\nvar closingTagAncestorBreakers = exports.closingTagAncestorBreakers = {\n  li: ['ul', 'ol', 'menu'],\n  dt: ['dl'],\n  dd: ['dl'],\n  tbody: ['table'],\n  thead: ['table'],\n  tfoot: ['table'],\n  tr: ['table'],\n  td: ['table']\n};\n\n/*\n  Tags which do not need the closing tag\n  For example: <img> does not need </img>\n*/\nvar voidTags = exports.voidTags = ['!doctype', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr'];\n//# sourceMappingURL=tags.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/himalaya/lib/tags.js\n// module id = 10\n// module chunks = 0","import * as difflib from \"difflib\";\nimport { xml, json } from \"vkbeautify\";\nimport parsersFactory, { ParserOptions, HimalayaOptions, Xml2jsOptions } from \"./parsers\";\nimport \"./overrideconsole\";\n\nexport { ParserOptions, HimalayaOptions, Xml2jsOptions };\n\nlet current_snapshot_object: { [key: string]: string } = {};\nexport function registerSnapshots(snapshot_object: { [key: string]: string }, name: string)\n{\n    current_snapshot_object = snapshot_object;\n    current_suite = new AutoSnapshotSuite(current_level, name);\n}\n\nclass AutoSnapshot\n{\n    public key: string;\n    public text: string;\n    public diff: Array<string>;\n}\n\nlet auto_snapshot_siute_history = new Array<AutoSnapshotSuite>();\nclass AutoSnapshotSuite\n{\n    public snapshots = Array<AutoSnapshot>();\n    public level = 0;\n    private fail_counter_for_autosnapshot = 0;\n    private last_automagic_snapshot_spec = \"\";\n    private last_automagic_snapshot_number = 0;\n    private name: string;\n\n    constructor(snapshot_level: number, suite_name: string)\n    {\n        this.level = snapshot_level;\n        this.name = suite_name;\n    }\n\n    public getSnapshotAutomagically_saveActual(actual: string): string\n    {\n        let auto_snapshot = new AutoSnapshot();\n\n        if (current_spec === this.last_automagic_snapshot_spec)\n        {\n            this.last_automagic_snapshot_number++;\n        }\n        else\n        {\n            this.last_automagic_snapshot_number = 1;\n            this.last_automagic_snapshot_spec = current_spec;\n        }\n\n        auto_snapshot.key = create_one_liner(`${current_spec} ${this.last_automagic_snapshot_number}`);\n        auto_snapshot.text = create_one_liner(actual);\n        this.snapshots.push(auto_snapshot);\n\n        let snapshot = current_snapshot_object[auto_snapshot.key];\n        return snapshot ? snapshot : \"\";\n    }\n\n    public hasFailure(): boolean\n    {\n        return this.fail_counter_for_autosnapshot > 0;\n    }\n\n    public reportFailure(diff: Array<string>)\n    {\n        this.snapshots[this.snapshots.length - 1].diff = diff;\n        this.fail_counter_for_autosnapshot++;\n    }\n\n    public getText(): string\n    {\n        let snapshot_file_text = \"\\n**** If actual is valid, update your snapshot with the following ****\\n{\";\n\n        let has_snapshots = false;\n\n        for (let snapshot of this.snapshots)\n        {\n            has_snapshots = true;\n            snapshot_file_text += `\\n\\t\"${snapshot.key}\": \\`${snapshot.text}\\`,`;\n        }\n\n        if (has_snapshots)\n        {\n            snapshot_file_text = snapshot_file_text.slice(0, snapshot_file_text.length - 1);\n            snapshot_file_text += \"\\n}\\n\\n\";\n        }\n\n        return snapshot_file_text;\n    }\n\n    public pushToHistory()\n    {\n        auto_snapshot_siute_history.push(this);\n    }\n\n    public getHTML(): string\n    {\n        if (typeof document !== \"undefined\") {\n            document.body.style.fontFamily = \"Courier New\";\n            document.body.style.whiteSpace = \"nowrap\";\n        }\n        if (!this.name) { throw \"name not defined for snapshot suite\"; }\n\n        if (!this.hasFailure())\n        {\n            return `<p style=\"color: green; font-size: 25px; font-weight: bold;\">===Auto snapshot suite, ${this.name}, has no problems!===</p>`;\n        }\n\n        let snapshot_file_html = `<p style=\"color: red; font-size: 25px; font-weight: bold;\">===Suite, ${this.name}, had problems===</p>`;\n\n        this.snapshots.forEach((snapshot) =>\n        {\n            if (snapshot.diff)\n            {\n                snapshot_file_html += `<div>>Test: \"${snapshot.key}\" did not match the snapshot:</div><br //>`;\n                snapshot.diff.forEach((d) =>\n                {\n                    if (d.length >= 3 && (d.slice(0, 3) === \"---\" || d.slice(0, 3) === \"+++\") || d.slice(0, 2) === \"@@\")\n                    {\n                        return;\n                    }\n                    else if (d.charAt(0) === \"-\")\n                    {\n                        snapshot_file_html += `<span style=\"color: red\">${d.replace(/&nbsp;/g, \"&amp;nbsp;\").replace(/ /g, \"&nbsp;\")}</span><br //>`;\n                    }\n                    else if (d.charAt(0) === \"+\")\n                    {\n                        snapshot_file_html += `<span style=\"color: green\">${d.replace(/&nbsp;/g, \"&amp;nbsp;\").replace(/ /g, \"&nbsp;\")}</span><br //>`;\n                    }\n                    else\n                    {\n                        snapshot_file_html += `${d.replace(/&nbsp;/g, \"&amp;nbsp;\").replace(/ /g, \"&nbsp;\")}<br //>`;\n                    }\n                });\n            }\n        });\n\n        snapshot_file_html += `<p style=\"text-decoration: underline; font-weight: bold;\">If actual is valid, update your snapshot with the following <//p>`;\n        snapshot_file_html += \"<div style='color: blue;'>{\";\n\n        let has_snapshots = false;\n\n        for (let snapshot of this.snapshots)\n        {\n            has_snapshots = true;\n            snapshot_file_html += `<br //>&nbsp;&nbsp;&nbsp;&nbsp;\"${snapshot.key}\": \\`${snapshot.text.replace(/&nbsp;/g, \"&amp;nbsp;\")}\\`,`;\n        }\n\n        if (has_snapshots)\n        {\n            snapshot_file_html = snapshot_file_html.slice(0, snapshot_file_html.length - 1);\n            snapshot_file_html += \"<br //>}</div></p>\";\n        }\n\n        return snapshot_file_html;\n    }\n}\n\n/************ Jasmine Reporter ************/\n\nlet current_suite: AutoSnapshotSuite | null;\nlet current_spec = \"\";\nlet current_level = 0;\njasmine.getEnv().addReporter({\n    suiteStarted: function (result)\n    {\n        current_level++;\n    },\n    specStarted: function (result)\n    {\n        current_spec = result.fullName;\n    },\n    suiteDone: function (result)\n    {\n        current_level--;\n\n        if (current_suite && current_level < current_suite.level)\n        {\n            if (current_suite.hasFailure)\n            {\n                // console.error(current_suite.getText());\n            }\n\n            current_suite.pushToHistory();\n            current_suite = null;\n        }\n    },\n    jasmineDone: function (results)\n    {\n        if (current_suite)\n        {\n            if (current_suite.hasFailure)\n            {\n                // console.error(current_suite.getText());\n            }\n\n            current_suite.pushToHistory();\n            current_suite = null;\n        }\n\n        if (auto_snapshot_siute_history.length === 0)\n        {\n            return;\n        }\n\n        let html_summary = auto_snapshot_siute_history.reduce(\n            (prev_html, curr_suite) =>\n            {\n                return prev_html + \"<br //>\" + curr_suite.getHTML();\n            }, \"\");\n\n        if (typeof document !== \"undefined\") {\n            document.body.innerHTML = html_summary + document.body.innerHTML;\n        } else {\n            console.log(html_summary);\n        }\n    }\n});\n\n/*************** Matching logic ***************/\n\n/**\n * Add more entries to this array if you have other exclusions for snapshot checks\n */\nexport let KeyExceptionList = [\"typeof\"];\n\nexport function ResetExceptionList()\n{\n    KeyExceptionList = [\"typeof\"];\n}\n\ndeclare var console;\n\nexport function MatchesSnapshot(snapshot: string, actual: string, automagic?: boolean)\n{\n    if (actual !== snapshot)\n    {\n        let diff: string[] = difflib.unifiedDiff(snapshot.split(\"\\n\"), actual.split(\"\\n\"));\n\n        if (automagic)\n        {\n            if (!current_suite) { throw \"autoagic snapshot with no registered snapshot object\"; }\n\n            current_suite.reportFailure(diff);\n        }\n\n        let diff_string = \"\\n\";\n        diff_string += `**** ${current_spec} diff *****\\n\\n`;\n\n        diff.forEach(d =>\n        {\n            if (d !== \"--- \\n\" && d !== \"+++ \\n\" &&\n                !(d.length > 5 && d.slice(0, 2) === \"@@\"))\n            {\n                diff_string += d + \"\\n\";\n            }\n        });\n\n        diff_string += \"\\n\";\n\n        if (!automagic)\n        {\n            let one_line_actual = create_one_liner(actual);\n\n            diff_string += \"**** If the Actual is valid, update the snapshot with this ****\\n\";\n            diff_string += ` ----- Formatted ------\\n${actual}\\n\\n ----- Single Line ------\\n${one_line_actual}`;\n        }\n        console.error(diff_string);\n\n        fail(`Actual does not match snapshot. See above. `);\n    }\n}\n\nfunction create_one_liner(actual: string)\n{\n    let one_line_actual = actual.replace(/\\n/g, \"\").replace(/\\t/g, \"\").replace(/\\\\\"/g, `\\\\\\\\\\\\\"`);\n    while (one_line_actual.indexOf(\"  \") !== -1)\n    {\n        one_line_actual = one_line_actual.replace(/(  )/g, \" \");\n    }\n\n    return one_line_actual;\n}\n\n/**\n * compares an HTML or XML values to a snapshot\n * @param snapshot the snapshot to compare the actual to\n * @param actual the actual xml/html string to compare to the snapshot\n */\nexport function MatchesXMLSnapshot(snapshot: string, actual: string)\n{\n    expectxml(actual).toMatchSnapshot(snapshot);\n}\n\n/**\n * compares a snapshot to a json string\n * @param snapshot the snapshot to compare the actual to\n * @param actual the json string to compare to the snapshot\n */\nexport function MatchesJSONSnapshot(snapshot: string, actual: string)\n{\n    let prettyActual = actual ? json(actual) : actual;\n    let prettySnapshot = snapshot ? json(snapshot) : snapshot;\n\n    MatchesSnapshot(prettySnapshot, prettyActual);\n}\n\n/**\n * Compares the snapshot to the actual option. Note this method will stringify\n * the actual value for the snnapshot compare and remove any key/values that contain the\n * strings in the KeyExceptionList\n * @param snapshot the snapshot to compare the actual to\n * @param actual The actual JS object to compare to the snapshot\n */\nexport function MatchesJSSnapshot(snapshot: string, actual: any)\n{\n    expectjs(actual).toMatchSnapshot(snapshot);\n}\n\nexport function expectjs(actual: Object)\n{\n    return new SnapshotJSInner(actual);\n}\n\nexport function expectxml(xml_actual: string, parser?: string, parserOptions?: ParserOptions)\n{\n    return new SnapshotXMLInner(xml_actual, parser, parserOptions);\n}\n\nabstract class SnapshotInner<T extends Object | string>\n{\n    protected actual: T;\n\n    constructor(actual: T)\n    {\n        this.actual = actual;\n    }\n\n    public afterApplying(transformFunction: (actual: T) => T)\n    {\n        this.actual = transformFunction(this.actual);\n        return this;\n    }\n}\n\nexport class SnapshotJSInner extends SnapshotInner<Object>\n{\n    private parsed_values = new Array<object>();\n\n    constructor(actual: Object)\n    {\n        super(actual);\n        this.actual = actual;\n    }\n\n    public toMatchSnapshot(snapshot?: string): void\n    {\n        let prettyActual = this.actual ? json(this.getOrderedStringifyAndClean()) : \"\";\n\n        let prettySnapshot = snapshot;\n        let use_autosnapshot = false;\n        if (snapshot === null || snapshot === undefined)\n        {\n            if (!current_suite) { throw \"Use of autosnapshot without registering snapshot object\"; }\n\n            use_autosnapshot = true;\n            let auto_snapshot = current_suite.getSnapshotAutomagically_saveActual(prettyActual);\n            prettySnapshot = auto_snapshot ? json(auto_snapshot) : \"\";\n        }\n        else\n        {\n            prettySnapshot = snapshot ? json(snapshot) : snapshot;\n        }\n\n        MatchesSnapshot(prettySnapshot, prettyActual, use_autosnapshot);\n    }\n\n    private getOrderedStringifyAndClean()\n    {\n        let keys = this.collectAllKeysAndRemoveCircular(this.actual);\n        return JSON.stringify(this.actual, keys);\n    }\n\n    private collectAllKeysAndRemoveCircular(js_object: any)\n    {\n        const allKeys = new Array<string>();\n\n        let jsonStr = JSON.stringify(js_object, (key: string, val: any) =>\n        {\n            if (this.isIEPooOrCurcularReferences(key, val))\n            {\n                return;\n            }\n\n            allKeys.push(key);\n            return val;\n        });\n\n        this.actual = JSON.parse(jsonStr);\n\n        return allKeys.sort((a: string, b: string) => (a > b) ? 1 : -1);\n    }\n\n    private isIEPooOrCurcularReferences(key, value)\n    {\n        if (typeof key === \"string\" && KeyExceptionList.some((ex) => key.indexOf(ex) !== -1))\n        {\n            return true;\n        }\n        else if (this.IsCurcularDependency(value))\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    private IsCurcularDependency(value: any)\n    {\n        if (value && typeof value === \"object\")\n        {\n            if (this.parsed_values.indexOf(value) === -1)\n            {\n                this.parsed_values.push(value);\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class SnapshotXMLInner extends SnapshotInner<string>\n{\n    protected parser: (parser: string, parserOptions?: ParserOptions) => any;\n    protected parserOptions?: ParserOptions;\n\n    constructor(xml_actual: string, parser?: string, parserOptions?: ParserOptions)\n    {\n        super(xml_actual);\n        this.parser = parsersFactory(parser);\n        this.parserOptions = parserOptions;\n        this.actual = xml_actual;\n    }\n\n    public toMatchSnapshot(snapshot?: string): void\n    {\n        let js_actual = this.parser(this.actual, this.parserOptions);\n        expectjs(js_actual).toMatchSnapshot(snapshot);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import himalaya = require(\"himalaya\");\n\nfunction removeEmptyNodes(nodes) {\n  return nodes.filter(node => {\n    if (node.type === \"element\") {\n      node.children = removeEmptyNodes(node.children);\n      return true;\n    }\n    return node.content.length;\n  });\n}\n\nfunction stripWhitespace(nodes) {\n  return nodes.map(node => {\n    if (node.type === \"element\") {\n      node.children = stripWhitespace(node.children);\n    } else {\n      node.content = node.content.trim();\n    }\n    return node;\n  });\n}\n\nfunction removeWhitespace(nodes) {\n  return removeEmptyNodes(stripWhitespace(nodes));\n}\n\nexport interface HimalayaOptions {\n    preservesWhitespace?: boolean;\n}\n\nexport let parse = (xml, options?: HimalayaOptions) => {\n    let json = himalaya.parse(xml);\n\n    let preservesWhitespace = (options || {}).preservesWhitespace !== false;\n    if (preservesWhitespace) {\n        json = removeWhitespace(json);\n    }\n\n    return json;\n};\n\n\n// WEBPACK FOOTER //\n// ./src/parsers/himalaya.ts","import X2JS = require(\"x2js\");\n\nexport interface Xml2jsOptions {}\n\nexport let parse = (xml) => {\n   const X2JS2 = X2JS as any; // don't hate me, their typings suck\n   const x2js = new X2JS2();\n\n   return x2js.xml2js(xml);\n};\n\n\n// WEBPACK FOOTER //\n// ./src/parsers/x2js.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"x2js\"\n// module id = 14\n// module chunks = 0"],"sourceRoot":""}